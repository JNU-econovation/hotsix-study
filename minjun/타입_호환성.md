![Untitled](https://github.com/JNU-econovation/hotsix-study/assets/129190157/90bb04f3-bb42-45b2-a68b-1139ba49268c)

## 기본 타입의 호환성

```jsx
let num1: number = 10;
let num2: 10 = 10;

num2 = num1; //에러
```

다운캐스트, 슈퍼타입에서 서브타입으로 대입시 에러 발생 (직사각형은 정사각형이다)

```jsx
let num1: numver = 10;
let num2: 10 = 10;

num1 = num2;
```

업캐스트, 모든 상황에 가능하다. (정사각형은 직사각형이다)

```jsx
let a: unknown = 1; // number -> unknown
let b: unknown = "hello"; // string -> unknown
let c: unknown = true; // boolean -> unknown
let d: unknown = null; // null -> unknown
let e: unknown = undefined; // undefined -> unknown
let f: unknown = []; // Array -> unknown
let g: unknown = {}; // Object -> unknown
let h: unknown = () => {}; // Function -> unknown
```

unknown 타입은 모든 타입보다 위에 있어서 unknown 타입 변수에는 모든 타입 값 할당하는 것이 가능하다. → 모든 타입을 부분집합으로 갖는 전체 집합이다.

```jsx
let unknownVar: unknown;

let a: number = unknownVar; //unknown -> number은 오류 발생
```

반대로 unknown 타입의 값은 any를 제외한 어떤 타입의 변수도 할당 할 수 없다.

```jsx
let a: never = 1; // number -> never 오류 발생
let b: never = "hello"; // string -> never 오류 발생
let c: never = true; // boolean -> never 오류 발생
let d: never = null; // null -> never 오류 발생
let e: never = undefined; // undefined -> never 오류 발생
let f: never = []; // Array -> never 오류 발생
let g: never = {}; // Object -> never 오류 발생
```

never은 계층도 상 가장 아래에 있다. 모든 타입들의 부분집합으로, 공집합이라고 할 수 있다. 어떤 타입도 never 타입으로 다운 캐스팅 할 수 없다. 반대로 never 타입은 모든 타입으로 업캐스팅 할 수 있다.

```jsx
function errorFunction(): never {
  throw new Error();
}
```

함수가 값을 반환하는 것 자체가 말이 안될 때 활용한다.

```jsx
function voidExam() {
  function voidFunc(): void {
    console.log("hi");
    return undefined;
  }

  let voidVar: void = undefined;
}
```

함수의 반환값 타입이 void이지만 undefined를 반환해도 오류가 발생하지 않는다.

```jsx
function anyExam() {
  let unknownVar: unknown;
  let anyVar: any;
  let undefinedVar: undefined;
  let neverVar: never;

  anyVar = unknownVar;

  undefinedVar = anyVar;
  neverVar = anyVar;
}
```

any 타입은 계층도를 무시한다. 모든 타입의 슈퍼타입이기도 하고 모든 타입의 서브타입이기도 하다. (never 제외)

never타입은 순수한 공집합으로, 어떤 타입도 다운캐스트 할 수 없다. any도 마찬가지다.

## 객체 타입의 호환성

```jsx
type Animal = {
  name: string,
  color: string,
};

type Dog = {
  name: string,
  color: string,
  breed: string,
};

let animal: Animal = {
  name: "기린",
  color: "yellow",
};

let dog: Dog = {
  name: "돌돌이",
  color: "brown",
  breed: "진돗개",
};

animal = dog; // 정상 실행
dog = animal; // 오류 발생
```

animal을 dog에 할당할 때 오류가 발생하는 것으로 보아 animal이 dog의 슈퍼타입 인 것을 알 수 있다. animal은 name과 color 프로퍼티를 갖고 있고, dog는 breed라는 프로퍼티를 추가적으로 갖고있다.

따라서 animal은 name과 color 프로퍼티를 갖는 모든 객체들을 포함하는 집합으로 볼 수 있고, 여기에 breed 프로퍼티를 추가로 갖는 dog 타입도 포함하므로 animal이 dog의 슈퍼타입인 것이다.

(어떤 객체가 dog 타입에 포함되면 무조건 animal 타입에도 포함된다.)

```jsx
type Book = {
  name: string,
  price: number,
};

type ProgrammingBook = {
  name: string,
  price: number,
  skill: string,
};

let book: Book;
let programmingBook: ProgrammingBook = {
  name: "한 입 크기로 잘라먹는 리액트",
  price: 33000,
  skill: "reactjs",
};

book = programmingBook;
programmingBook = book; // 오류

let book2: Book = {
  // 오류 발생
  name: "한 입 크기로 잘라먹는 리액트",
  price: 33000,
  skill: "reactjs",
};
```

book타입으로 정의된 변수에 programmingbook 타입의 초기값을 설정하면 오류가 발생한다. 변수를 객체 리터럴로 초기화 할 때 초과 프로퍼티 검사가 발동해서 오류가 난 것인데, 이 기능은 타입에 정의된 프로퍼티 외에 다른 초과된 프로퍼티를 갖는 객체를 변수에 할당 할 수 없도록 막는다.

```jsx
...

let book3: Book = programmingBook;
```

앞서 만들어둔 변수를 초기화 값으로 사용하면 오류가 발생하지 않는다.
