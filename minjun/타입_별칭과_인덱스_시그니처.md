## 타입 별칭(Type Alias)

```tsx
let user: {
  id: number;
  name: string;
} = {
  id: 1,
  name: "cs",
};
```

객체 타입을 사용할 때 직접 해당 타입을 명시하였습니다. 그런데 같은 타입의 변수를 여러개 사용해야 한다면 아래와 같이 타입을 중복해서 정의해서 사용하게 됩니다.

```tsx
let user1: {
  id: number;
  name: string;
  nickname: string;
} = {
  id: 1,
  name: "cs",
  nickname: "winter",
};

let user2: {
  id: number;
  name: string;
  nickname: string;
} = {
  id: 2,
  name: "jh",
  nickname: "summer",
};
```

타입 정의는 중복되는 코드입니다. 이는 유지보수를 어렵게 하고 가독성을 떨어트립니다. 그리고 때로는 같은 타입을 재사용하거나 또 다른 이름으로 부르고 싶은 경우도 존재합니다. 타입 별칭을 사용하면 변수를 선언하듯 타입을 별도로 정의할 수 있습니다.

`type 타입이름 = 타입` 형태로 타입을 정의합니다.

```tsx
type User = {
  id: number;
  name: string;
  nickname: string;
};

let user: User = {
  id: 1,
  name: "cs",
  nickname: "winter",
};
```

단, 동일한 스코프에 동일한 이름의 타입 별칭을 선언하는 것은 불가능합니다. 타입 별칭은 타입 관련 문법이기 때문에 컴파일 결과 자바스크립트 코드에서는 사라집니다.

## 인덱스 시그니처(Index Signature)

인덱스 시그니쳐는 객체 타입을 유연하게 정의할 수 있도록 돕는 특수한 문법입니다. 예를 들어 다양한 국가들의 영어 코드를 저장하는 객체가 있다고 가정하겠습니다.

```tsx
type CountryCodes = {
  Korea: string;
  UnitedState: string;
  UnitedKingdom: string;
};

let countryCodes: CountryCodes = {
  Korea: "ko",
  UnitedState: "us",
  UnitedKingdom: "uk",
};
```

countryCodes에 100개의 프로퍼티가 추가되어야 한다면 타입 정의에도 각 프로퍼티를 모두 정의해주어야 합니다. 아직 추가되어야 할 프로퍼티 이름과 값을 알지 못한다면 타입을 정의하지 못할 것입니다.

하지만 객체의 키와 값의 타입 규칙을 알고 있다면 인덱스 시그니쳐를 이용하여 간단하게 타입을 정의할 수 있습니다.

```tsx
type CountryCodes = {
  [key: string]: string;
};

let countryCodes: CountryCodes = {
  Korea: "ko",
  UnitedState: "us",
  UnitedKingdom: "uk",
  // (... 약 100개의 국가)
  Brazil: "bz",
};
```

`[key : string] : string`, 키가 string 타입이고 값이 string 타입인 모든 프로퍼티를 포함한다는 의미입니다.

주의할 점은 인덱스 시그니쳐는 정의된 규칙을 위반하지만 않으면 모든 객체를 허용합니다. 빈 객체는 이 규칙을 위반하지는 않으므로 오류가 발생하지 않습니다.

```tsx
type CountryNumberCodes = {
  [key: string]: number;
};

let countryNumberCodes: CountryNumberCodes = {};
```

반드시 포함해야 하는 프로퍼티가 있다면 직접 명시할 수 있습니다. 단, 인덱스 시그니쳐의 value 타입과 직접 추가한 프로퍼티의 value 타입이 호환되거나 일치해야 합니다.

```tsx
type CountryNumberCodes = {
  [key: string]: number;
  Korea: number; // Korea: string; 에러
};
```

## 열거형(Enum) 타입

여러가지 값들에 각각 이름을 부여해 열거해두고 사용하는 타입입니다. 열거형 타입은 자바스크립트에는 존재하지 않고 오직 타입스크립트에서만 사용할 수 있는 특별한 타입입니다.

```tsx
enum Role {
  ADMIN = 0,
  USER = 1,
  GUEST = 2,
}

const user1 = {
  name: "admin",
  role: Role.ADMIN, //0
};
```

enum 멤버에 숫자 값을 직접 할당하지 않아도 0부터 1씩 늘어나는 값으로 자동 할당됩니다.

```tsx
enum Role {
  ADMIN, // 0
  USER, // 1
  GUEST, // 2
}
```

자동 할당되는 값은 기본적으로 0부터 시작합니다. 만약 이 값을 변경하고 싶다면 다음과 같이 시작하는 위치에 값을 직접 할당해주면 됩니다. 그럼 자동으로 그 아래의 멤버들은 1씩 증가된 값으로 할당됩니다.

```tsx
enum Role {
  ADMIN = 10, // 10
  USER, // 11
  GUEST, // 12
}
```

enum의 멤버에는 숫자 말고도 문자열 값도 할당할 수 있습니다. 숫자형 열거형에서 숫자만으로는 그 값이 어떤 의미인지 추측하기 힘들 때 프로퍼티의 값으로 사용할 수 있습니다.

```tsx
enum Role {
  ADMIN,
  USER,
  GUEST,
}

enum Language {
  korean = "ko",
  english = "en",
}

const user1 = {
  name: "admin",
  role: Role.ADMIN, // 0
  language: Language.korean, // "ko"
};
```

### enum의 컴파일 결과

타입스크립트 타입 관련 코드는 컴파일할 때 사라집니다. 그런데 enum은 컴파일될 때 다른 타입들처럼 사라지지 않고 자바스크립트 객체로 변환됩니다.

```tsx
var Role;
(function (Role) {
  Role[(Role["ADMIN"] = 0)] = "ADMIN";
  Role[(Role["USER"] = 1)] = "USER";
  Role[(Role["GUEST"] = 2)] = "GUEST";
})(Role || (Role = {}));
var Language;
(function (Language) {
  Language["korean"] = "ko";
  Language["english"] = "en";
})(Language || (Language = {}));
var user1 = {
  name: "admin",
  role: Role.ADMIN,
  language: Language.korean,
};
```

### (+) enum을 사용하지 말아야 하는 이유

- enum은 Tree-shaking(번들링 할 때 사용하지 않는 코드 제거하는 과정)이 되지 않아 번들 파일의 크기를 증가시킬 수 있습니다.
