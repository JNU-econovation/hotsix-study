# 타입정하기 애매할 때 (union type, any, unknown)

이 변수에 들어올게 string일지 number일지 아직 애매하다면

방법이 몇가지 있습니다.

> 가장 Easy 한 Union type 사용
> 

"이 변수엔 string 또는 number가 들어올 수 있습니다~" 라고 타입정의를 하고싶으면 | 연산자를 씁시다.

OR 연산자 같은 느낌인데 이런 타입을 전문용어로 Union type 이라고 부릅니다.

```tsx
let 이름: string | number = 'kim';
let 나이: (string | number) = 100;
```

심심하면 괄호쳐도 됩니다.

이러면 name, age 변수엔 string 또는 number만 들어올 수 있습니다.

그리고 **할당하는 순간 타입은 string 또는 number 중 하나로 변합니다.**

그럼 array, object 자료 만들 때 union type (OR 연산자) 쓰려면 어떻게 할까요

```tsx
var 어레이: number[] = [1,'2',3]
var 오브젝트: {data : number} = { data : '123' }
```

위 코드에 정의된 어레이와 오브젝트는 지금 타입 때문에 에러가 납니다.

**array와 object 자료에 number 또는 string**이 들어올 수 있게 타입을 좀 고쳐보시길 바랍니다.

- 고쳐보기!
    
    ```tsx
    var 어레이: (number | string)[] = [1,'2',3]
    var 오브젝트: {data : (number | string) } = { data : '123' }
    ```
    
    이러면 될듯요
    
    특징은 변수에 정의된 Union 타입은 할당과 동시에 OR 역할이 사라집니다.
    
    array, object에 정의된 Union 타입은 OR 연산자가 유지됩니다.
    
    어레이 이자식 함정카드 있음
    
    ```tsx
    var 어레이: number | string[] = [1,'2',3]
    ```
    
    1234 혹은 어레이가 들어갈 수 있게 됨
    

> any 타입 (이건 뭐 바이러슨가?)
> 

아무 자료나 집어넣을 수 있는 타입입니다.

쉽게 비유하면 실드해제? 바이러스? 트로이목마? 정도?

```tsx
let 이름: any = 'kim';
이름 = 123;
이름 = undefined;
이름 = [];
```

any 타입은 실드 해제 문법이기 때문에 갑자기 타입을 마구 바꿔도 에러가 나지 않습니다.

any 타입은 좋다고 막쓰면 안되는데

그럼 타입관련 버그가 생길 경우 왜 그런지 추적하기가 어려우니까요.

타입 실드를 안씌우면 타입스크립트를 쓸 이유가 없습니다.

그래서 비상시 쓰는 **변수 타입체크 해제기능** 이런 용도로 씁시다.

> any 보다는 unknown 을 씁시다!
> 

요즘 타입스크립트는 unknown 타입을 사용합니다.

any와 똑같이 모든 타입을 집어넣을 수 있습니다.

```tsx
let 이름: unknown = 'kim';
이름 = 123;
이름 = undefined;
이름 = [];
```

이래도 에러가 나지 않습니다.

아직 어떤 타입이 들어올지 모를 경우, 다양한 타입을 집어넣어야할 경우 이걸 사용해보시길 바랍니다.

중요한 특징은

1. unknown 타입엔 모든 자료 다 집어넣을 수 있음

2. 자료집어넣어도 타입은 그대로 unknown입니다.

```tsx
let 이름: unknown;

let 변수1: string = 이름;
let 변수2: boolean = 이름;
let 변수3: number = 이름;
```

당연히 unknown 타입을 다른 곳에 집어넣으려고 하면

그쪽 실드가 발동해서 에러가 납니다.

(any는 안그럼)

```tsx
let 이름: unknown;
이름[0];
이름 - 1;
이름.data;
```

이래도 에러가 납니다.

(any는 안그럼)

왜냐면 타입스크립트는 **정확하고 확실한걸 좋아합니다.**

확실하지않은 타입에 뺄셈해주고 그런거 싫어합니다.

숫자가 아닌걸 뺄셈할 수는 없으니까요.

타입스크립트에선 뺄셈은 number 류의 타입만 할 수 있고

.name 이런건 object 류의 타입만 할 수 있다라고 미리 정의되어있습니다.

그래서 결론은 아직 뭘 집어넣을지 모르겠는데 약간의 안정성을 도모하고 싶으면 unknown 타입을 써봅시다.

근데 실은 코드짜다가 any, unknown 부여할 경우는 별로 없습니다.

```tsx
let 나이: string|number;
나이 + 1;
```

분명 자바스크립트에선 문자에도 +1 가능하고 숫자에도 +1 가능합니다.

근데 저건 에러가 납니다.

```tsx
let 나이: unknown = 1;
나이 + 1;
```

분명히 나이라는 변수는 1인데 +1 안해줍니다.

왤까요?

타입스크립트는 언제나 확실한걸 좋아한다고 했습니다.

지금 변경하려는 변수의 타입이 확실해야 연산을 수행해줍니다.

**그래서 -1은 확실하게 왼쪽에 있는게 number 타입일 때만 가능합니다.**

unknown은 number타입이 아닙니다.

string|number 이것도 number 타입이 아닙니다. **(union type은 새로운 타입을 하나 만든 겁니다)**

+1도 마찬가지입니다.

- unknown vs any
    
    ![Untitled](%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%20%E1%84%8B%E1%85%A2%E1%84%86%E1%85%A2%E1%84%92%E1%85%A1%E1%86%AF%20%E1%84%84%E1%85%A2%20(union%20type,%20any,%20unknown)%2077627a7993494b7db401fe8192180bf0/Untitled.png)
    
    - 이새낀 뭐 그냥 바이러스임
    - 온갖곳 쉴드 해제시켜서 다른 변수 타입도 뚫고 들어가버림…
    
    ![Untitled](%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%20%E1%84%8B%E1%85%A2%E1%84%86%E1%85%A2%E1%84%92%E1%85%A1%E1%86%AF%20%E1%84%84%E1%85%A2%20(union%20type,%20any,%20unknown)%2077627a7993494b7db401fe8192180bf0/Untitled%201.png)
    
    - myname 이 오브젝트이므로, 타입스크립트에서 에러를 발생시켜주고 있는 모습
    - 이름은 오브젝트 변수이므로, 변수 1(스트링)에는 들어올 수 없음

![Untitled](%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%20%E1%84%8B%E1%85%A2%E1%84%86%E1%85%A2%E1%84%92%E1%85%A1%E1%86%AF%20%E1%84%84%E1%85%A2%20(union%20type,%20any,%20unknown)%2077627a7993494b7db401fe8192180bf0/Untitled%202.png)

- 왜 나에대한 기준만 엄격한건데!!!
    
    ![Untitled](%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%20%E1%84%8B%E1%85%A2%E1%84%86%E1%85%A2%E1%84%92%E1%85%A1%E1%86%AF%20%E1%84%84%E1%85%A2%20(union%20type,%20any,%20unknown)%2077627a7993494b7db401fe8192180bf0/Untitled%203.png)
    
    - 타입스크립트의 엄격함
        - 간단한 수학연산도 타입이 맞아야만 한다
        
    
    ![Untitled](%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%20%E1%84%8B%E1%85%A2%E1%84%86%E1%85%A2%E1%84%92%E1%85%A1%E1%86%AF%20%E1%84%84%E1%85%A2%20(union%20type,%20any,%20unknown)%2077627a7993494b7db401fe8192180bf0/Untitled%204.png)
    
    - 엄격함을 사랑하는 타스
        - string 타입 + 1 허용
        - number 타입 + 1 허용
        - string|number 타입 + 1 불가능!
    
    ![Untitled](%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%20%E1%84%8B%E1%85%A2%E1%84%86%E1%85%A2%E1%84%92%E1%85%A1%E1%86%AF%20%E1%84%84%E1%85%A2%20(union%20type,%20any,%20unknown)%2077627a7993494b7db401fe8192180bf0/Untitled%205.png)
    
    - 변수가 1인데 왜 -1이 안되는 거임?
        - 타입스크립트는 엄격한거 좋아함
        - 숫자타입이어야 숫자마냥 연산해줌
            - unkown은 숫자타입이 아닌거임!
    
    **Narrowing / Asswertion을 배우자!**
    

> 정리
> 

### **any**

- 모든 타입을 허용합니다.
- TypeScript에서 타입 검사를 느슨하게 하므로 개발 당시에는 문제가 없으나 애플리케이션 또는 웹 페이지 개발 후 예기치 못한 문제가 발생할 가능성이 매우 높습니다.

### **unknown**

- 모든 타입을 허용합니다.
- any 타입과는 다르게 프로퍼티 또는 연산을 하는 경우 컴파일러가 체크합니다. 그러므로 문제 되는 코드를 미리 예방할 수 있습니다.